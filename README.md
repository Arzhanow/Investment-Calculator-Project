Тук ще документирам всичко, свързано с проекта:
- Кое създавам, как го създавам и защо го създавам
- Оптимизация
- Автоматизация
- Добри практики

1. ЗАПОЧВАМЕ СЪС СЪЗДАВАНЕ НА ПАПКАТА COMPONENTS, както и със създаването
на няколко компонента. Започваме с първия компонент - Header

* Header.jsx * 
1. Импортираме логото от папка assets -> "../assets/investment-calculator-logo.png";
2. Компонентът връща header елемент, който съдържа img, h1.

-> App.jsx:
Импортираме Header.jsx и го слагаме в return

2. СЪЗДАВАМЕ ВТОРИ КОМПОНЕНТ, КОЙТО ЩЕ ОТГОВАРЯ ЗА ПРИЕМАНЕТО НА НАШИТЕ ВХОДНИ ДАННИ - UserInput

* UserInput.jsx *
1. Създаваме секция с id="user-input" --> ориентираме се според index.css и в тази секция
създаваме и div element с клас "input-group" -> <p> -> <label> и <input type"number />, като ги 
групираме две по две, съответно да стане симетрично -> ориентираме се как е зададен нашия css файл.

3. ЗАПОЧВАМЕ РАБОТА ПО ЛОГИКАТА НА НАШИЯ ПРОЕКТ 

Импортираме useState() React Hook в нашия файл UserInput, за да управляваме състоянията и логиката 

3.1. От нас зависи дали искаме поотделно да управляваме и четирите полета или искаме да имаме един обект,
който обединява всички тези входни стойности(input values)

3.2. Избираме ги поотделно, като задаваме примерни първоначални(стойности по подразбиране)
3.3. Създаваме функция, която ще контролира промяната в тези наши input полета -> ние избираме дали да
създадем четири различни функции, които да работят с нашите стойности поотделно или да имаме една обща, която да е 
свързана и с четирите стойности -> избираме втората опция. 

3.4. Създаваме функцията handleChange(inputIdentifier, newValue) и казваме, че ще обновяваме при промяна на една от
стойностите, ще обновяваме на база старо събитие, защото не бива като променим една стойност да се губят всичките.
Затова казваме, че на база предишни стойности ще връщаме предишния масив, като ще променим само една от стойностите
(т.е. да кажем, че ще променим всички, следователно ще минем през този процес четири пъти, трябва да се раздели, защото
има вариант да се промени само някоя/някои/не всички стойности спрямо тези по подразбиране). Определяме коя е тази
стойност спрямо двойката kvp, която правим [inputIdentifier]: newValue, а преди това подаваме и стария масив -> ...prevUserInput

3.5. !!! Започваме с добавянето на Event Listeners -> onChange={() => handleChange('ИМЕТО_НА_ПОЛЕТО')}, 
ако подадем само {handleChange}, React
произволно ще избере стойности, а нас ни интересува правилно да предадем двата параметъра на нашата фунцкия -> handleChange. 
След като получим информация за кой тип поле искаме да направим промяна(Initial investment, annual investment,
Expected return, Duration), трябва да получим и самата стойност(число). Това се получава като в анонимната функция добавим 
обект на събитие (event), който има свойство target -> което реферира към самата стойност, след като добавим и .value ->
event.target.value !!!

-Добавяме value={userInput.initialInvestment} -> за да се показва стойността по подразбиране преди да сме я презаписали чрез
промяна на състоянието и фунцкията, която създадохме. Сега следва да повторим и за останалите три елемента.

-> App.jsx:
Импортираме UserInput.jsx и го слагаме в return под Header.jsx, но над тях слагаме <> - фрагмент, защото трябва да имаме
родителски елемент над два равнопоставени (sibling elements), за да се изведат от функцията/компонента.

4. СЪЗДАВАМЕ ТРЕТИ КОМПОНЕНТ, КОЙТО Е СВЪРЗАН С РЕЗУЛТАТИТЕ - Results

!Важно е да уточним едно нещо: резултатите, които ще пазим в нашия компонент 'Results' се базират на информация, която се
намира в друг компонент, и понеже не може да предаваме свободно информация между компоненти, трябва да 'повдигнем състоянието'
до App.jsx, където да съставим логика за намиране на тези резултати (посредством формулите, които са ни зададени и в 
.util/investment.js) и оттам да я подадем като аргумент на компонента Results.

Защо е важно "повдигането" на състоянието? → Защото в React данните текат само отгоре надолу (parent → child). С други думи, 
ако искаме да предаваме информация между компоненти, то трябва да се върнем към родителския компонент (App.jsx), който може
да предава информация на всички свои деца.

Съответно моделът на работа е следния:
UserInput (въвеждане на данни) → App (изчисления, useState()) → Results (показване на резултати)

Какво точно правим?

4.1. Премахваме следното съдържание от компонента UserInput :

const [userInput, setUserInput] = useState({
    initialInvestment: 10000,
    annualInvestment: 1200,
    expectedReturn: 6,
    duration: 10,
  });
и го добаввяме в App.jsx.

4.2. Импортираме useState в App.jsx -> import { useState } from "react";

4.3. Премахваме следното съдържание от компонента UserInput:

function handleChange(inputIdentifier, newValue) {
    setUserInput((prevUserInput) => {
      return {
        ...prevUserInput,
        [inputIdentifier]: newValue,
      };
    });
  }
и го добавяме в App.jsx

Сега, за да можем да извикаме функцията handleChange от вътрешността на компонента UserInput(мястото в App.jsx, където го извикваме),
трябва да предадем указател(pointer) като стойност на компонента. Добавяме реквизит(prop) с име по наш избор(onChange) =>
onChange={handleChange} -> тук не я извикваме като добавяме скоби накрая -> handleChange(), а ПРОСТО Я ЗАДАВАМЕ КАТО СТОЙНОСТ!
И сега в компонента UserInput можем да приемем този реквизит(prop) onChange, който за стойност има функцията handleChange.
Остава да извикаме тази функция в компонента UserInput, затова където извиквахме handleChangе, посредством event(обект на събитие),
сега извикваме onChange, която е същата функция, просто предадена чрез реквизит(prop). Сега повтаряме това в компонента UserInput
и за останалите три input елемента.

Но също така в компонента UserInput се нуждаем и от потребителския вход, който изтрихме най-напред. Нуждаем се от обекта, 
за да обновим стойностите на тези полета. Следователно компонента приема втори реквизит(prop): напр. userInput.
За да го приема като реквизит, трябва да се върнем в App.jsx и да го въведем като реквизит, който приема стойността от масива,
където въвеждаме useState() -> следователно това изглежда така: 

<UserInput userInput={userInput} onChange={handleChange} />

Това цялото нещо го направихме, за да можем тази информация да я подадем и на компонента Results.jsx

4.4. Дефинираме компонента Results
Подаваме {input} като реквизит на компонента Results и импортираме Results в App.jsx, след което създаваме реквизита
в елемента Results, който се намира в App.jsx и му предаваме стойността userInput, защото това е идеята на 'State Lifting' ->
<Results input={userInput} /> (input и userInput са две едни и същи неща, просто кръстихме реквизита(prop) по друг начин! )

!!! АКО НА ТОЗИ ЕТАП ОТВОРИМ КОНЗОЛАТА В БРАУЗЪРА ЩЕ ВИДИМ КАК ПОЛУЧАВАМЕ ОБЕКТ ОТ СТОЙНОСТИ И КОГАТО ГИ ПРОМЕНЯМЕ, ПОЛУЧАВАМЕ
НОВИ И НОВИ ОБЕКТИ ОТ СТОЙНОСТИ, КОИТО ПРИТЕЖАВАТ ОБНОВЕНИТЕ СТОЙНОСТИ!!!

Можем да извлечем нашите стойности чрез нашия реквизит(prop), който в случая е нашето състояние на потребителския вход,
което се обновява, тоест можем да извлечем стойностите от това състояние и това е нещо, което много често ще се налага в React
проекти -> извличане и изчисляване на стойности спрямо състояние - (Computing values).

4.5. Импортираме функцията calculateInvestmentResults в Results.jsx
Ако в този момент отпечатаме на конзолата резултата от тази функция, ще видим, че имаме конкатениране, или неправилно
изведен резултат, заради тип стринг (някъде в програмата). Решението на това нещо е просто да добавим '+' пред newValue, в 
двойката ключ-стойност (kvp от key value pair), което ще го преобрази в число -> [inputIdentifier]: +newValue

4.6. Създаваме си таблица с глава и тяло, където чрез помощта на map() метод отпечатваме резултатите под формата на таблица.
4.7. Импортираме и форматиращата функция, която ни помага да закръглим и да поставим $ пред изпечатаната сума. Общо взето 
посочваме информацията, която по условие искаме да покажем за всяка една година.

За да пресметнем totalInterest си създаваме две константи и прилагаме следните формули:
1) const initialInvestment =
    resultsData[0].valueEndOfYear -
    resultsData[0].interest -
    resultsData[0].annualInvestment;

2) const totalInterest =
    yearData.valueEndOfYear -
    yearData.annualInvestment * yearData.year -
    initialInvestment;

4.8. За да пресметнем totalAmountInvested си създаваме още една константа със следната формула:
const totalAmountInvested = yearData.valueEndOfYear - totalInterest;

Общо взето с това програмата ни е готова, с изключение на няколко проблеми, които е възможно да възникнат:
1. Ако въведем нулева или отрицателна стойност на duration (продължителността)
- Решаваме този проблем, когато извеждаме условно дадена информация (Outputting Content/Data Conditionally)

Създаваме си променлива, която проверява това условие:
const inputIsValid = userInput.duration >= 1;

И отпечатваме само ако е truthy стойност <==> ако удовлетворява условието, зададено с променливата
{inputIsValid && <Results input={userInput} />}

Ако не удовлетворява условието -> извеждаме параграф, който ни уведомява къде е проблемът:

{!inputIsValid && (
        <p className="center">Please, enter a duration greater than zero.</p>
      )}

И с това приключваме дотук, като разбира се, приложението може да се надгражда още много!
